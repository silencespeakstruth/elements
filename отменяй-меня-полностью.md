# Отменяй меня полностью

_Нам не дано предугадать как удаленный сервер отзовется._

## Минздрав предупреждает: блокирующие вызовы вредят вашему здоровью

Вредят! Еще как вредят! Рано или поздно из-за неотмененного блокирующего вызова случится [^1] production incident, а вслед за ним придут и чувство вины, угрызения совести, стресс, апатия, бессонница и экзистенциальный кризис среднего возраста. Если в  системе таких вызовов много, то год ее поддержки считается за три — и вы рано постареете.

Суть проблемы в следующем: за блокирующим вызовом скрывается (часто неочевидная) потеря контроля над происходящим — контроля, который был у исполняющего этот вызов потока еще мгновение тому; именно "был", а не "есть": ведь в момент совершения такого вызова поток вынужденно доверяется внешней силе, о которой достоверно ничего не знает и знать не может; которая, вероятно, действует за сотни километров отсюда [^2] и которой до судьбы этого потока никакого дела нет.

Звучит еще хуже, чем ипотека! Толковые программисты осторожны с зависимостями, особенно неявными. Хороший софт — хорош как раз потому, что состоит из независимых, самодостаточных модулей. Однако и на микроуровне — уровне конкретных вызовов всяких там `foo` и `bar` — это остается жизненно важным. 

## Timeout это вам не это

И вот на арене появляется timeout — некоторое количество единиц физического времени — например, миллисекунд — которое программист почему-то посчитал достаточным для выполнения данного конкретного блокирующего вызова. Если за отведенное время завершение не наступило, то безрезультатное ожидание прерывается грубой силой [^3].

На первый взгляд, стало лучше. По крайней мере, потеря контроля [^4] уже не носит характер всеохватывающей безнадежности, а _ограничена сверху_. Но нет, нет, нет, [это никуда не годится](https://vorpus.org/blog/timeouts-and-cancellation-for-humans):

> But in fact these two `timeout=` arguments mean totally different things. The first one means "try to acquire the lock, but give up after 10 seconds". The second one means "try to fetch the given URL, but give up if at any point any individual low-level socket operation takes more than 10 seconds". Probably the whole reason you're using requests is that you don't want to think about low-level sockets, but sorry, you have to anyway. In fact it is currently not possible to guarantee that `requests.get` will return in any finite time: if a malicious or misbehaving server sends at least 1 byte every 10 seconds, then our requests call above will keep resetting its timeout over and over and never return.

Кроме блестящих аргументов из процитированного выше блогпоста (которые я не буду пересказывать, прочтите сами), следует назвать и такой: timeout'ы, как и deadlin'ы, сложно тестировать — оба завязаны на течение физического времени и глубоко запрятанное глобальное состояние [^5].

## Абстракция животворящая

На самом деле "прерви исполнение, если вызов не успеет завершиться за `n` миллисекунд" это частный случай более абстракной формулировки: "прерви исполнение, если наступило некоторое user-defined событие". Если "user-defined событие" переименовать на "событие отмены", то вот простейший из возможных код:

```
#include <stdatomic.h>

struct cancel_event {
    _Atomic bool cancelled;
}

bool is_cancelled(struct cancel_event *ce) {
    return atomic_load_explicit(&ce->cancelled, memory_order_relaxed);
}

void cancel(struct cancel_event *ce) {
    atomic_store_explicit(&ce->cancelled, true, memory_order_relaxed);
}
```

Разумно требовать, чтобы сигнал отмены мог выжить в многопоточной среде, поэтому `_Atomic` оправдан. Поскольку не стоит задача посредством `bool cancelled` как-то упорядочивать чтения и записи до и после отмены, выбран `memory_order_relaxed`. Неформально этот код повествует примерно следующее: "есть потокобезопасное событие отмены, которое не следует воспринимать как примитив синхронизации и на его основе координировать многопоточность; весь его смысл лишь в нем самом, а конкретно в том, чтобы перейти в `true` когда и если отмена совершится". Просто. Понятно. Легко использовать.

Из простых, понятных и легких в использовании абстракций с помощью простых, понятных и легких в использовании композиций можно конструировать сложное. Скажем, можно суммировать два сигнала отмены, получая третий с такой весьма полезной на деле семантикой: если хотя бы один из двух слагаемых отменился, сумма тоже считается отмененной; или так: сумма считается отмененной, когда оба слагаемых отменены. Можно связать два произвольных сигнала отмены, тем самым приравняв их друг к другу: если отменен любой из двух, то отменен и оставшийся. В мире полиморфизмов, [композитов](https://en.wikipedia.org/wiki/Composite_pattern) и автоматической сборки мусора это скорее тривиальный, нежели продвинутый код [^6].

Нехитрые рассуждения привели нас в Рим всея concurrency — к священной кооперативности. В наш атомный век иные люди верят в плоскую Землю; другие — в демократию; третьи — в "preemptive VS cooperative". И все таки Земля — круглая; демократия — не более, чем возможность выбора между Coca-Cola или Pepsi [^7]; и никакой сколько нибудь разумный concurrency не может быть не-кооперативным в своей основе. Надеюсь, что первые две мысли очевидны, а вот последняя требует обоснования. 

## Киберкоммунизм... опять...

Кооперативность на деле означает вызов какого-нибудь [sched_yield](https://man7.org/linux/man-pages/man2/sched_yield.2.html) _в правильных местах_. Вообще, именно `*yield`-подобные вызовы являются скелетом всякой кооперативности, поверх которого наращивается мясо очередного not invented here concurrency framework'а. Но раз уж мы заговорили о _правильных местах_, то почему бы там же не проверять и `is_cancelled`? В идеале, framework сделает это сам, минимизируя boilerplate в прикладном коде [^8]. 

Но это только вершина айберга. В действительности кооперативность есть ни что иное, как ваше любимое "от каждого по способностям — каждому по потребностям", только с поправкой на multithreading. Именно поэтому-то формулировка "конкурирующие потоки", бездумно перекочевавшая из англоязычной литературы, не уместна: смысл не в конкуренции, а во взаимоподдержке и взаимодополнении. Посыл такой: каждая единица мультизадачности по мере своих сил — то есть, по мере того как ей достается CPU и в меру эффективности своего алгоритма — решает какую-то подзадачу _в их made-by-human декомпозиции_ [^9] и это решение нужно (будет потребляться) каким-то другими единицами мультазадчности. Классический `producer-consumer` ярко иллюстрируют сказанное выше: по мере своих способностей `producer` производит нечто, необходимое для работы `consumer`'а; всякий раз, когда `producer` сгенерировал достаточное на его взгляд количество работы и хочет отдохнуть, он добровольно `yield`ится и наступает очередь `consumer`а поработать; если же `consumer` работы для себя не находит или устал, то пора и ему `yield`нуться. Цикл повторяется.

![This the the way.](https://i.ytimg.com/vi/LaiN63o_BxA/maxresdefault.jpg "This the the way.")

Принципиально важно понять, что _вытесняющие планировщики_ — тупые и потому неэффективные. Грубо и жестоко прерывая чью-то работу по истечению некоторого кванта времени есть риск совершить это в _неправильном месте_. Причем риск высокий: правильных мест — их мало, а следовательно мала и вероятность оказаться именно в таком месте в момент вытеснения. 
Таки да: места бывают правильные и неправильные. Это обусловлено физикой протекающего где-то там незнамо-где процесса. Вот, например, в [hard driv'ах](https://en.wikipedia.org/wiki/Hard_disk_drive#Performance_characteristics) "правильным местом" называется момент, когда поток становится зависим от считывающей головки и ее соблаговоления переместиться в нужную точку в пространство-времени и произвести чтение искомых сегментов. Сопоставимо со скоростью CPU, это длится так долго, что дожидаться заверешния [^10] на CPU — глупо, если не греховно! Гораздо разумнее уйти по добровой воле во имя добра, а для этого нужен тот самый добрый `yield`. Добро, добро, добро.

Еще раз для протокола: мир программирования полон процессов, которые протекают гораздо медленнее и гораздо менее предсказуемы и надежны, чем сам CPU и его локальное окружение. В первую очередь, это взаимодействие с внешними дисками или суетный бег нулей и единиц по проводам, соединяющим разделенные океаном материки. Без кооперативности concurrency попросту уродлив. Выходит, что в _разумном мире_ кооперативность... неизбежна [^11].

А еще неизбежны человеческие ошибки. Неизбежны случаи, когда заветный `yield()` оказался забыт и это почему-то никем не было замечено на review, и код упорхнул на production на встречу новому бизнес-инциденту. Равно неизбежны и ошибки аппаратуры: когда заветный `yield()` во всех правильных местах присутствует, но бесполезен — потому что то, чего он ждет, из-за аппаратного сбоя никогда не произойдет: поток очередной раз 1) прыгает на CPU, 2) убеждается, что "еще не готово" и 3) упрыгивает обратно с CPU — и так до бесконечности. [Livelock](https://stackoverflow.com/a/6155978) detected!

Вот именно поэтому и полезны события отмены, которые позволяют произвольно сложным способом ограничиться сверху, не потеряв при этом ни в тестировании, ни в декомпозиции, ни производительности. А еще они полезны потому что concurrency по естественным причинам [носит древовидный характер](https://en.wikipedia.org/wiki/Pstree) — ведь родительские единицы многозадачности порождают дочерние. Если 1) каждый такой узел завязан на свое собственное событие отмены и 2) с помощью ранее упомянутых комбинаторов отмена родителя влечет за собой отмену и всех его детей [^12], то события отмены вместе с retr'аями становятся главным механизмом технически грамотного risk management'а. Они превращаются в _способ мыслить_ о происходящем, способ обеспечивать инварианты, выполнять обещанные гарантии. 

Дальше [читайте](https://www.erlang.org/doc/man/supervisor.html#supervision-principles) сами.

[^1]: Разумеется, в самый неподходящий момент.

[^2]: Любое сетевое обращение к действительно _удаленному_ серверу — т.е. серверу, находящемуся далеко.

[^3]: Попутно, есть есть технические возможность и необходимость, происходит освобождение захваченных ресурсов. Например, закрывается злополучный file handler или `fin` улетает по TCP, тем самым в одностороннем порядке обрывая связь.

[^4]: Избавиться от этого полностью — невозможно. Чтобы потери контроля не происходило в случае ранее приводимого примера с сетевым обращением к машине где-то далеко... эта машина должна находиться рядом.

[^5]: Если вам не кажется это утверждение убедительным, то вы либо мало тестировали, либо мазохист.

[^6]: На голом `C`, конечно, понадобятся мозги и руки. Впрочем, ничего нового... на голом `C` всегда нужны мозги и руки.

[^7]: Оба продукта принадлежат одной и той же корпорации.

[^8]: Например, `Async<'T>` из того же `F#` проверяет состояние .NET'овского `CancellationToken` на каждой итерации каждого цикла [^8] — и не только цикла! — автоматически. It just works!

[^9]: Concurrency всегда про декомпозицию: если решаемую задачу нельзя разумно разделить на подзадачи, выполнение которых хотя бы отчасти возможно одновременно a-ka параллельно, то и никакой ни мультизадачности, ни параллельности неоткуда взяться: они избыточны.

[^10]: Если оно вообще произойдет...

[^11]: А коммунизм?!

[^12]: Иными словами, событие отмены растекается вниз по всему поддереву.