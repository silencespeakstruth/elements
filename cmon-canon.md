# Конструкции лечащие или калечащие

*...или о том как синтаксис и семантика подписали мировую.*

В мейнстриме принято трястись над именованием. Люди,
- которых ~10 лет в школе и еще лет 5 в институте натаскивали на решения вроде "пусть даны `x`, `x'`",
- которые от корки до корки прошли по меньшей мере матсат, матан, теорвер и ни разу не встретили там ни одного обозначения длинее трех знаков...

...вдруг становятся навязчиво обеспокоены именами переменных и проводят остаток жизни в `бесконечныхПоискахСамогоЛучшегоНазванияЧтобДажеСлучайныйПрохожийСмогСразуПонять` то, что, в общем-то, нужно было написать комметарием рядом и для чего комментарии придуманы.

Так вот, болезненная фиксация на именах отвлекает от гораздо более насущной и губительной проблемы: от сущностей, на которые эти имена навешаны. Как тут не вспомнить буддийского монаха, изрекшего мудрое "палец, указующий на Луну, не есть Луна".

# Синтаксис + Семантика = Любовь

*Семантически* одно и то же обычно можно представить многими способами *синтаксически*. Например `0` и `255 - (127 + 128)`: разные массивы символов означают одинаковый ноль (два нуля не могут быть разными, правда?).

Давайте думать об этом иначе: синтаксис задает множество грамматически корректных *конструкций*, семантику которых определяет их вычисление (как процесс *осмысления* написанного). В таком случае есть два принципиальных уровня сопоставления смыслов между собой:
- уровень синтаксиса: здесь сопоставляются не сами луны, а направления указывающих на них пальцев;
- уровень семантики: где никаких пальцев уже нет, только луны и ничего кроме лун и их объектных свойств.

А что если решительно и бесповоротно запретить все это синтаксическое разнообразие? Зачем? Да чтоб уровень синтаксиса стал эквивалентен уровню семантики: если объекты равны по (языковой) конструкции, то автоматически равны и результаты их вычисления -- и наоборот. Тогда о лунах можно будет судить по "пальцам, на них указующим"" и буддийский монах окажется кругом не прав, а наши программы значительно упростятся -- ведь одним махом отпадет необходимость всюду прокидывать *смысловой контекст*: например, чтоб понять, что два SQL-скрипта делают одно и то же будет достаточно сравнить их посимвольно, без малейшей необходимости что-то там где-то там запускать или обкладывать тестами (оперирующими на втором уровне результатов вычисления, иначе толку от них?).

**Если синтаксис и семантика эквивалентны друг другу, то последняя просто не нужна: поладить с массивами символов гораздо проще -- и человеку, и компилятору!** Если не совершенно не нужно, то, по крайней мере, не нужна в столь вредных для здоровья и корректности программ количествах...

Но запретить как? Есть два пути:
1. Беспощадный фашисткий запрет всякого разнообразия на уровне публичных интерфейсов: "кто не с нами -- тот под нами!", "один фреймворк -- один фюррер!" и все в таком духе. Это не работает примерно никогда, а если все же иногда срабатывает -- то лучше бы не сработало.
2. Гораздо более благоразумный подход: *имплиситно* сводить все разнообразие синтаксических конструкций по смыслу одного и того же к некоторой субъективно выбранной *единственной канонической записи* и далее оперировать ей и только ей (при необходимости осуществляя обратное преобразование, если требуется возвращать данные в их оригинальном формате, что встречается не так уж часто на самом деле).

Скажем:

- Email адреса не чувствительны к регистру по спецификаци? Хранить их только в lower-case.
- Сложные многоуровневые фильтры? Хранить из только к КНФ, в лексиграфическом порядке переменных.
- Много RO файлов? Хранить их SHA512.

...и так далее, и тому подобное.

Все ради того, чтоб подружить два мира.