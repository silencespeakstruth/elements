# All ya need is fixpoint

_— Как-то раз цыган решил объяснить лошади fixpoint'ы...
<br/>
— И что, лошадь сдохла?!
<br/>
— Нет, вернулись туда, откуда начали..._

## Кто виноват?

Скажу сразу: виноваты монографии по лямбда-исчилению.

Потому что в них написано, что лямбда-исчисление — это (в том числе) универсальный [^1] язык однозначного, недвусмысленного описания произвольного вычисления. Раз уж вычисление "произвольное", то должны быть выразимы и всевозможные здоровые зацикленности — когда алгоритм каким-либо образом зависит от _размера_ выходящих данных. Например, такой:

```haskell
len [] = 0            -- Длина пустого листа всегда равна нулю.
len _:xs = 1 + len xs -- Длина непустого листа зависит от длины "хвоста".
```

Очевидно, что чем лист длиннее, тем больше единиц находится в конечной сумме. А вот неочевидное: даже если переписать определение выше как-нибудь вот так:

```haskell
len l = case l of
    []   -> 0
    _:l' -> 1 + len l'
```

...или вот так:

```haskell
len l = if l == [] then 0 else 1 + (len (tail l))
```

...то все равно не удается избежать рекурсии: определение `len` _всегда_ содержит само себя.

Проблема в том, что никакой `len` как _именованная абстракция_ [^2] в лямбда-исчислении не существует. Почему? Потому что там определены только лишь неименованные — анононимые — абстракции. Единственное именованное что там есть — это (никогда не меняющиеся и поэтому лучше сказать "постоянные") "переменные". Вот `\есть_имя -> (есть имя есть_имя)` это вполне себе законный лямбда-терм и `есть_имя` в данном случае ни на кого не ссылается и никуда не указывает. [Глазами программиста — это неинициализированная ссылка с той разницей, что даже неинициализированная ссылка куда-нибудь да указывает — хотя бы в `NULL`, а тут такого нет.]

Чтобы `есть_имя` стало работать как указатель (на какой-то другой лямбда-терм — потому что ничего кроме них в лямбда-исчислении, конечно же, не бывает), необходим тертий — и последний — обязательный ингридиент: необходимо "применение". Допустим, вот такое: `( (\есть_имя -> (есть имя есть_имя)) (\есть_другое_имя -> есть_другое_имя) )`. Теперь лямба-терм `\есть_другое_имя -> есть_другое_имя` _применяется_ [^3] к другому лямбда-терму `\есть_имя -> (есть_имя есть_имя)`. В результате этого применения `есть_имя` действительно начинает работать как настоящий указатель: `(есть_имя есть_имя)` по смыслу становится рекурсивными вызовом, превращаясь в `( (\есть_другое_имя -> есть_другое_имя) (\есть_другое_имя -> есть_другое_имя) )`, что в свою очередь ровно по тем же правилам превращается в `\есть_другое_имя -> есть_другое_имя`. Итого — **внимание, сейчас мозгам будет больно** — выражение `( (\есть_имя -> (есть имя есть_имя)) (\есть_другое_имя -> есть_другое_имя) )` — каким бы сложным на первый взгляд оно не казалось — натурально позволяет:

- _не меняя базовых определений_, выйти за сковывающие границы анонимности, превозмочь изначально безымянную природу лямбда-абстракций, таким образом
- _с математической надежностью_ внедрив в лямбда-исчиление указатели, что делает
- _требующие не-анонимности_ рекурсивые определения — принципиально возможными,
- вследствие чего всю конструкцию выше можно воспринимать как ссылку, процесс трансформации термов — как [разыменование](http://mycpp.ru/perl/book/7/7.3.html), указывающее на _по-прежнему анонимный терм_ `\есть_другое_имя -> есть_другое_имя`.

Из всего вышенаписанного можно сделать поистине судьбоносный вывод: **по крайней мере в частных случаях рекурсивные определения принципиально возможно вопреки анонимности**. Разумеется, следующий шаг — попытаться обобщить: если это работает в частных случаях, то вдруг это же или нечто подобное работает во всех случаях?

## Что делать?

Транслировать все программы в лямбда-исчисление, конечно же. Почему? Да потому что все началось с попытки определить универсальный язык описания любых вычислений. А раз так, то значит любая корректная программа должна иметь по крайней мере один соответствующий ей лямда-терм. А раз этак, то каждую программу имеет смысл пытаться компилировать в три простейших конструкции лямбда-исчисления.

Осталось все таки (до)разобраться с циклами. Хочется, чтоб каждой итерации какого угодно цикла в процедурной программе соответствовал рекурсивный вызов чего-нибудь, что будет эквивалентно представлять такой цикл в нашем богатом мире лямбда-термов, лямбда-термов и лямбда-термов.

Умные люди рассуждают примерно так: давайте представим себе какое-то вычисление `F`, которое в своем определении рекурсивно, т.е. упоминает `F` по меньшей мере единожды. Выше таким `F` является `len` потому что `len` упоминает само себя. Тогда определение `F` выглядит как-нибудь вот так: `F = \x -> (... F ...)`, где троеточие с обеих сторон означает "все остальное" (которое сейчас не важно поскольку происходящее рассуждение должно быть максимально общим, а не зависеть от случайных частностей). [Отдельно замечу, что единственный кандидат на роль "гаранта рекурсии" это именно абстракция. Поэтому-то и фигурирует _обязательное_ `\x -> ...`. Это так потому что применение по смыслу является "вызовом" какой-либо уже существующей, заданной и определенной абстракции; само же определение находится в ее — этой абстракции — теле и нигде больше. Поэтому не быть `\x -> ...` у произвольного `F` никак не может и на произвольность выбора это никак не влияет.]

Ранее изобретенный способ "именования" анонимных по своей природе абстракций позволяет сделать еще один шажок вперед: `F = ( (\f -> (\x -> ... f x ...) ) F )` — равнозначным образом переписав все выражение как применение, таким образом превратив `f` в указатель.

Хоть этот шаг и кажется малозначительным, в действительности является решающим. В хорошей математике такое происходит сплошь и рядом: маленькая, почти незаметная деталь — мгновенно меняет все.

Последние выражние легко переписать как `F = REC F`, где `REC = \f -> (\x -> ... f x ...)`. Здесь мозги опять должны бы заныть от боли. Особенно от `F = REC F`. Мало кто заметит, но `REC` само себя нигде не упоминает, а значит не является рекурсией; **`REC` это обычнейшая лямбда-абстрация**. В такой записи единственное место, где рекурсия остается (и бросается в глаза!) это `F = REC F`.

Последнее позволяет исходную проблему свести к поиску такого `REC`, что `F = REC F` примерно в том же самом смысле в котором выражение `x * x = 9` сводится к поиску нужного `x` (которых в данном случае `-3` и `3` — ведь верных решений может быть ноль, строго одно или сколько угодно много). Теперь, дойдя до сюда, если найдется какой-нибудь способ находить такое `REC` автоматически для любого `F` — то это и станет решением.. для _любого_ `F`.

Но найдется ли?.. "That is the question" — сокрушался бы Шекспир, если бы "Ромео и Джульетта" были написаны на лямбда-исчислении.

Так вот, когда дано такое `REC` и дано такое `F`, что `F = REC F`, то `F` называется "fixpoint" от `REC`. Например, `0` является fixpoint от `\x -> x * x` потому что `0 = ( (\x -> x * x) 0 ) = 0 * 0 = 0`. Но ровно по той же причине и `1` является fixpoint'ом. А вот `2` уже не является, так как `2 != ( (\x -> x * x) 2 ) = 2 * 2 = 4`. Свойство "быть fixpoint'ом" по-умолчанию привязано к контексту какой-то _конкретной_ абстракции: один и тот же лямбда-терм может быть или не быть fixpoint'ом в зависимости от этой привязки.

**Сейчас мозгам будет очень больно**.

**Очень**.

_Фундаментальнейшая_ проблема какой-угодно рекурсии внезапно предстала как проблема поиска fixpoint'а от данного `REC` (которое, еще раз, само по себе нерекурсивно — это важно). Для решения нужно изобрести кракозяблю `FIX` чтоб выполнялось равенство `F = FIX REC`; тогда, как следствие банального переписывания `F = REC F`, получится что выполняется и `FIX REC = REC (FIX REC)`. Простым языком говоря, `FIX` это такой универсальный "поискатор" fixpoint'ов для конкретного _нерекурсивного_ `REC`, который ни что иное как способ внедрить в анонимную систему разыменование ссылок. Тут будет нелишним еще одни научный комменатрий: ух ты ж, блядь!

## Ух ты ж, блядь!

Именно такими словами было встречено открытие `FIX`-комбинатора:

```
FIX = ( \f -> ( (\x -> f (x x)) (\x -> f (x x)) ) )
```

Удивительнее всего в записе выше то, что она работает. Причем, сука, универсально! Вот буквально любое нерекурсивное `REC` применяется к этому — совершенно волшебному — `FIX` и после череды преобразований по тем же самым простым законам применения получается пугающее `FIX REC = REC (FIX REC)` каким бы этот `REC` ни был! Тут хочется заметить: ух ты ж, блядь.

А еще хочется заметить, что в изначально анонимной системе с приходом именованных указателей и разыменования, пришла и неограниченная рекурсия, позволяющая описывать неограниченные (в том числе даже бесконечные) циклы, что и делает лямбда-исчисление в конечном итоге Тьюринг-полным. Теперь поистине _любая_ возможная программа будет соответствовать по крайней мере одному лямбда-терму, что и оправдывает выбор лямбда-исчисления с его всего лишь тремя примитивами как "универсальный ассемблер", на котором можно запрограммировать что угодно, что в принципе можно запрограммировать...

[^1]: Буквально, а не фигурально: от слова "universum".

[^2]: Программисты ровно то же самое называют "именованной функцией". Именно поэтому, кстати, анонимные функции часто называют "лямбдами" — иногда даже на уровне keyword'ов ЯП, как у python: `labmda x: x` определяет "абстракцию" `\x -> x`.

[^3]: Внимательно следи за ~~руками~~ скобками: они имеют значение.