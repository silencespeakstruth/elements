# Невыносимая невычислимость бытия

_Доказательство того, что у Бога есть чувство юмора._

## До 1900 года нашей эры

...лучшие математики своего времени совершенно искренне верили во всесильность логики. Они верили, что любое грамматически верное высказывание на языке формальной логики [^1] можно или доказать, или опровергнуть, причем и доказать, и опровергнуть одновременно (то есть, получить противоречие) — нельзя. Другими словами, они свято верили
в постижимость по крайней мере математической истины.

Long stroy short, все они фатально ошибались.

Все, что написано ниже — это попытка нестрого, прибегая больше к интуиции, чем к формализму, объяснить в чем и как именно ошибались и почему эта ошибка именно "фатальная".

## Давид Гильберт, для друзей просто Дава

![Портрет Давида.](/%D0%BD%D0%B5%D0%B2%D1%8B%D0%BD%D0%BE%D1%81%D0%B8%D0%BC%D0%B0%D1%8F-%D0%BD%D0%B5%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D0%B1%D1%8B%D1%82%D0%B8%D1%8F-1.jpg "Портрет Давида.")

Его невозможно обойти молчанием, Давид был, пожалуй, самым ярким представителем навсегда уходящей эпохи. Вот его цитата:

> It remains to discuss briefly what general requirements may be justly laid down for the solution of a mathematical problem. I should say first of all, this: that it shall be possible to establish the correctness of the solution by means of a finite number of steps based upon a finite number of hypotheses which are implied in the statement of the problem and which must always be exactly formulated. This requirement of logical deduction by means of a finite number of processes is simply the requirement of rigor in reasoning.

Современным языком говоря, Давид утвержает, что любую математическую проблему можно решить _алгоритмически_. Напомню, что под "алгоритмом" мы понимаем _конечную_ последовательность некоторых ясно и несомненно определенных инструкций, которые за _конечное_ время гарантированно вычисляют некоторый результат; каким образом алгоритм параметризируется это не суть важно, но количество параметров так же должно быть _конечным_.

То есть, по мнению Гильберта решение какой угодно математической проблемы сводится к поиску алгоритма, который ее решит или поиску алгоритма, который покажет, что проблема решений не имеет. В обоих случаях артефактом мысли и мерилом истинности является именно алгоритм.

Отсюда понятно, почему определение алгоритма так сильно настаивает на конечности всех составляющих — ведь в целом математики без страха вглядываются в бездну бесконечности. Однако в этом конкретном случае выбора нет, поскольку речь идет о познании человеком математики; человек не в состоянии проверить бесконечно долгий поток инструкций и не в состоянии проверить результат алгоритма, который работает вечно и никогда не заканчивается. Уберите конечность хоть в каком месте определения — и познание математики средствами формальной логики в то же самое мгновение станет невозможным. 

## Познание математики средствами формальной логики? Што?

Да все просто. Формальна логика оперирует набором "правил вывода", иначе известных под собирательным именем "дедукция". Вот например: если известно, что `A` истинно и что `B` тоже истинно, то _из этого всенепременно следует_, что новое скомбинированное утверждение `A & B` тоже истинно.

Дедукция — это основа той самой [^2] формальной логики. При этом, дедукция — это элементарные алгоритмы. Получается, познание математики это процесс итеративного применения некоторого конечного круга алгоритмов, которые целенаправленно спроектированы таким образом, чтобы из истинных предпоссылок всегда выводить только лишь истинные следствия, вот и все. Мысль же Гильберта состоит в том, что последовательное сколь угодно (конечно!) долгое применение этих алгоритмов способно решить _любую_ математическую проблему whatsoever, если только она имеет хотя бы одно решение; а если она нерешаема, то сколь угодно (конечно!) долгое применение этих алгоритмов в итоге приведет ищущего математика к этому выводу и тем самым будет _строго доказано_, что данная проблема решений не имеет. О как!

Давид мог бы выразиться и парафразом Матфея:

> Ищите <математическое доказательство>, и найдете; ибо всякий ищущий находит.

## Давид ошибался

Матфей, похоже, тоже.

Есть математические проблемы, которые имеют решение, но найти это решение средствами дедукции нельзя сколько бы (конечно!) долго они не применялись. Равно: есть и математические проблемы, которые решений не имеют, но найти доказательство этому по тем же причинам невозможно.

И речь не про пределы возможностей человека. Не про то, что в наши нейронные сетки какие-то задачи просто не вмещаются. Не про то, что мы все тут смерты и поэтому Вечности с нами особо и поговорить-то не о чем. Речь о мирообразующих принципах, которые одинаково работают и в нашей, и не в нашей галактиках; которые были во время динозавров, есть сейчас и останутся после нас. Более того, существование таких проблем математически доказуемо. Не суетитесь, вдумайтесь: дедукция способна доказать _свои собственные_ пределы возможного. Я много лет живу с этим пониманием и много лет оно потрясает меня как будто впервые.

## Мир математики после 1900

...стремительно обрушился. В один прекрасный момент казавшиеся незыблимыми постулаты просто... рухнули, превратившись в руины. [Бертран Рассел](https://brianrabern.net/onewebmedia/FregeRussellCorr.pdf), ниже на фотографии, написал коротенькое письмецо. Современным языком говоря, он создал новый bug report. Поначалу казалось, что это маловажный bug и его будет легко починить; спустя год безуспешных попыток, математическое сообщество, наконец, осознало, что это critical bug, принципиальная ошибка засела в "kernelspac'е математики" и исправить ее, сохранив этот самый kernelspace — невозможно.

![Портрет Бертрана.](/%D0%BD%D0%B5%D0%B2%D1%8B%D0%BD%D0%BE%D1%81%D0%B8%D0%BC%D0%B0%D1%8F-%D0%BD%D0%B5%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D0%B1%D1%8B%D1%82%D0%B8%D1%8F-2.jpg "Портрет Бертрана.")

В истории развития ПО такого еще не бывало. Это должно быть что-то в духе, что завтра некоторый follower репозитория, допустим, с Linux'ом напишет небольшой комментарий в очередном pull request'е, в котором обнаружится critical bug, **требующий выкинуть весь исходный код ядра**. Весь. Целиком. Ни строчки кода ни сберечь. Представляете себе столь чудовищную катастрофу? Вот это произошло с математикой примерно в 1900. Последствия оказались соответствующими.

Это письмо повлекло цепную реакцию. Лучше год от года не становилось; только хуже. Апофеозом трагедии стал, на мой вкус, самый выдающийся интеллектуальный подвиг XX века: доказательство первой теоремы Курта Геделя о неполноте [^3], смысл которой сводился к тому, что:

> Любая дедуктивная система, в которой определена арифметика [^4], либо неполна, либо противоречива.

![Портрет Курта.](/%D0%BD%D0%B5%D0%B2%D1%8B%D0%BD%D0%BE%D1%81%D0%B8%D0%BC%D0%B0%D1%8F-%D0%BD%D0%B5%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D0%B1%D1%8B%D1%82%D0%B8%D1%8F-3.jpg "Портрет Курта.")

Допустить противоречивость такой системы ни за что нельзя. Потому что [ex falso sequitur quodlibet](https://en.wikipedia.org/wiki/Principle_of_explosion). Значит, эта система неполна, а "неполнота" как раз и означает, что не каждое объективно истинное или объективно ложное утвреждение на языке такой системы доказуемо. Возвращаясь к алгоритмам и (на тот момент, буквально уничтоженным) идеям Гильберта: математическая истина непозноваема _полностью_, алгоритмы не способны довести до всех возможных истинных утверждений; не каждая математическая проблема имеет алгоритмическое решение. Wasted.

## Я программист, а не математик; мне без разницы

Попытка хорошая, но нет. Вот, например, вполне себе прикладная и весьма востребованная индустрией разработки ПО проблема: нужен некоторый тулинг, который будет анализировать исходный код программы, не покидая уютненькую IDE, и выдавать warning'и, если какая-то функция хотя бы при каком-то из возможных исполнений программы впадает в бесконечный цикл. Или еще одна: есть многопоточная программа и нужен другой тулинг, который может вычислить, дойдет ли хотя бы одно из возможных исполнений этой программы до строчки номер `x` — например, вообще в этот конкретный `if` хоть когда-нибудь попадаем или нет?!

Угадайте что? Эти. Проблемы. Не. Имеют. Алгоритмического. Решения [^5]. 

Эти проблемы невозможно решить не из-за медленных компъютеров или плохо спроектированных языков программирования; не из-за того, что мы — невольники Млечного пути или бренного человеческого тела. Эти проблемы нельзя решить потому что таковы пределы возможного алгоритмов; таковы пределы возможного для _конечных_ последовательностей инструкций, которые за _конечное_ время решают поставленную перед ними задачу; таковы пределы возможного для _машин_ — и не важно, они сделаны из кремния или из других химических соединений из известной таблицы.

[^1]: Не существенно важной какой именно.

[^2]: В действительности "тех самых", ведь их много.

[^3]: Не много, не мало, Гедель — отец современной математики, которая до сих пор зализывает страшные раны, нанесенные ей XX веком. Разумеется, это мое субъективное мнение в меру моего незнания, не более. P.S. Теорем о неполноте две, после им была доказана еще и вторая.

[^4]: Определены натуральные числа и простейшие операции с ними как, например, суммирование — все то, что учат дети в начальной школе.

[^5]: Однако, если эти проблемы искусственно упростить, таким образом вырезав некоторое их разумное подмножество, то алгоритмические решения существуют. Тем не менее, в общем случае алгоритмическое решение — невозможно.
